{"ast":null,"code":"import { Struct } from './Struct.js';\nconst getPath = (object, pathArray) => {\n  return pathArray.reduce((prevObj, key) => prevObj && prevObj[key], object);\n};\nexport class VersionedStruct extends Struct {\n  constructor(type) {\n    let versions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    this.type = type;\n    this.versions = versions;\n    if (typeof type === 'string') {\n      this.versionPath = type.split('.');\n    }\n  }\n  decode(stream, parent) {\n    let length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    const res = this._setup(stream, parent, length);\n    if (typeof this.type === 'string') {\n      res.version = getPath(parent, this.versionPath);\n    } else {\n      res.version = this.type.decode(stream);\n    }\n    if (this.versions.header) {\n      this._parseFields(stream, res, this.versions.header);\n    }\n    const fields = this.versions[res.version];\n    if (fields == null) {\n      throw new Error(`Unknown version ${res.version}`);\n    }\n    if (fields instanceof VersionedStruct) {\n      return fields.decode(stream, parent);\n    }\n    this._parseFields(stream, res, fields);\n    if (this.process != null) {\n      this.process.call(res, stream);\n    }\n    return res;\n  }\n  size(val, parent) {\n    let includePointers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let key, type;\n    if (!val) {\n      throw new Error('Not a fixed size');\n    }\n    if (this.preEncode != null) {\n      this.preEncode.call(val);\n    }\n    const ctx = {\n      parent,\n      val,\n      pointerSize: 0\n    };\n    let size = 0;\n    if (typeof this.type !== 'string') {\n      size += this.type.size(val.version, ctx);\n    }\n    if (this.versions.header) {\n      for (key in this.versions.header) {\n        type = this.versions.header[key];\n        if (type.size != null) {\n          size += type.size(val[key], ctx);\n        }\n      }\n    }\n    const fields = this.versions[val.version];\n    if (fields == null) {\n      throw new Error(`Unknown version ${val.version}`);\n    }\n    for (key in fields) {\n      type = fields[key];\n      if (type.size != null) {\n        size += type.size(val[key], ctx);\n      }\n    }\n    if (includePointers) {\n      size += ctx.pointerSize;\n    }\n    return size;\n  }\n  encode(stream, val, parent) {\n    let key, type;\n    if (this.preEncode != null) {\n      this.preEncode.call(val, stream);\n    }\n    const ctx = {\n      pointers: [],\n      startOffset: stream.pos,\n      parent,\n      val,\n      pointerSize: 0\n    };\n    ctx.pointerOffset = stream.pos + this.size(val, ctx, false);\n    if (typeof this.type !== 'string') {\n      this.type.encode(stream, val.version);\n    }\n    if (this.versions.header) {\n      for (key in this.versions.header) {\n        type = this.versions.header[key];\n        if (type.encode != null) {\n          type.encode(stream, val[key], ctx);\n        }\n      }\n    }\n    const fields = this.versions[val.version];\n    for (key in fields) {\n      type = fields[key];\n      if (type.encode != null) {\n        type.encode(stream, val[key], ctx);\n      }\n    }\n    let i = 0;\n    while (i < ctx.pointers.length) {\n      const ptr = ctx.pointers[i++];\n      ptr.type.encode(stream, ptr.val, ptr.parent);\n    }\n  }\n}","map":{"version":3,"names":["Struct","getPath","object","pathArray","reduce","prevObj","key","VersionedStruct","constructor","type","versions","versionPath","split","decode","stream","parent","length","res","_setup","version","header","_parseFields","fields","Error","process","call","size","val","includePointers","preEncode","ctx","pointerSize","encode","pointers","startOffset","pos","pointerOffset","i","ptr"],"sources":["C:/Users/Abdullah/Desktop/Project/TTP-Project/client/node_modules/restructure/src/VersionedStruct.js"],"sourcesContent":["import {Struct} from './Struct.js';\n\nconst getPath = (object, pathArray) => {\n  return pathArray.reduce((prevObj, key) => prevObj && prevObj[key], object);\n};\n\nexport class VersionedStruct extends Struct {\n  constructor(type, versions = {}) {\n    super();\n    this.type = type;\n    this.versions = versions;\n    if (typeof type === 'string') {\n      this.versionPath = type.split('.');\n    }\n  }\n\n  decode(stream, parent, length = 0) {\n    const res = this._setup(stream, parent, length);\n\n    if (typeof this.type === 'string') {\n      res.version = getPath(parent, this.versionPath);\n    } else {\n      res.version = this.type.decode(stream);\n    }\n\n    if (this.versions.header) {\n      this._parseFields(stream, res, this.versions.header);\n    }\n\n    const fields = this.versions[res.version];\n    if ((fields == null)) {\n      throw new Error(`Unknown version ${res.version}`);\n    }\n\n    if (fields instanceof VersionedStruct) {\n      return fields.decode(stream, parent);\n    }\n\n    this._parseFields(stream, res, fields);\n\n    if (this.process != null) {\n      this.process.call(res, stream);\n    }\n    return res;\n  }\n\n  size(val, parent, includePointers = true) {\n    let key, type;\n    if (!val) {\n      throw new Error('Not a fixed size');\n    }\n\n    if (this.preEncode != null) {\n      this.preEncode.call(val);\n    }\n\n    const ctx = {\n      parent,\n      val,\n      pointerSize: 0\n    };\n\n    let size = 0;\n    if (typeof this.type !== 'string') {\n      size += this.type.size(val.version, ctx);\n    }\n\n    if (this.versions.header) {\n      for (key in this.versions.header) {\n        type = this.versions.header[key];\n        if (type.size != null) {\n          size += type.size(val[key], ctx);\n        }\n      }\n    }\n\n    const fields = this.versions[val.version];\n    if ((fields == null)) {\n      throw new Error(`Unknown version ${val.version}`);\n    }\n\n    for (key in fields) {\n      type = fields[key];\n      if (type.size != null) {\n        size += type.size(val[key], ctx);\n      }\n    }\n\n    if (includePointers) {\n      size += ctx.pointerSize;\n    }\n\n    return size;\n  }\n\n  encode(stream, val, parent) {\n    let key, type;\n    if (this.preEncode != null) {\n      this.preEncode.call(val, stream);\n    }\n\n    const ctx = {\n      pointers: [],\n      startOffset: stream.pos,\n      parent,\n      val,\n      pointerSize: 0\n    };\n\n    ctx.pointerOffset = stream.pos + this.size(val, ctx, false);\n\n    if (typeof this.type !== 'string') {\n      this.type.encode(stream, val.version);\n    }\n\n    if (this.versions.header) {\n      for (key in this.versions.header) {\n        type = this.versions.header[key];\n        if (type.encode != null) {\n          type.encode(stream, val[key], ctx);\n        }\n      }\n    }\n\n    const fields = this.versions[val.version];\n    for (key in fields) {\n      type = fields[key];\n      if (type.encode != null) {\n        type.encode(stream, val[key], ctx);\n      }\n    }\n\n    let i = 0;\n    while (i < ctx.pointers.length) {\n      const ptr = ctx.pointers[i++];\n      ptr.type.encode(stream, ptr.val, ptr.parent);\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}