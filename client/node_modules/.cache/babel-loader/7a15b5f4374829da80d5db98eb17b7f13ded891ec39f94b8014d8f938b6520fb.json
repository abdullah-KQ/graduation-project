{"ast":null,"code":"/** Text hyphenation in Javascript.\n *  Copyright (C) 2021 Yevhen Tiurin (yevhentiurin@gmail.com)\n *  https://github.com/ytiurin/hyphen\n *\n *  Released under the ISC license\n *  https://github.com/ytiurin/hyphen/blob/master/LICENSE\n */\n(function (root, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof module === \"object\" && module.exports) {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    // Browser globals (root is window)\n    root.createHyphenator = factory();\n  }\n})(this, function () {\n  var SETTING_DEFAULT_ASYNC = false,\n    SETTING_DEFAULT_DEBUG = false,\n    SETTING_DEFAULT_HTML = false,\n    SETTING_DEFAULT_HYPH_CHAR = \"\\u00AD\",\n    SETTING_DEFAULT_MIN_WORD_LENGTH = 5,\n    SETTING_NAME_ASYNC = \"async\",\n    SETTING_NAME_DEBUG = \"debug\",\n    SETTING_NAME_HTML = \"html\",\n    SETTING_NAME_HYPH_CHAR = \"hyphenChar\",\n    SETTING_NAME_MIN_WORD_LENGTH = \"minWordLength\";\n  var _global = typeof global === \"object\" ? global : typeof window === \"object\" ? window : typeof this === \"object\" ? this : {};\n  function cloneObj(source) {\n    var target = {};\n    for (var key in source) {\n      target[key] = source[key];\n    }\n    return target;\n  }\n  function keyOrDefault(object, key, defaultValue) {\n    if (key in object) {\n      return object[key];\n    }\n    return defaultValue;\n  }\n  function exceptionsFromDefinition(patternsDefinition, hyphenChar) {\n    return patternsDefinition.exceptions.reduce(function (exceptions, exception) {\n      exceptions[exception.replace(/\\-/g, \"\")] = exception.replace(/\\-/g, hyphenChar);\n      return exceptions;\n    }, {});\n  }\n  function createHyphenator(patternsDefinition, options) {\n    options = options || {};\n    var\n      //\n      asyncMode = keyOrDefault(options, SETTING_NAME_ASYNC, SETTING_DEFAULT_ASYNC),\n      caches = {},\n      debug = keyOrDefault(options, SETTING_NAME_DEBUG, SETTING_DEFAULT_DEBUG),\n      exceptions = {},\n      hyphenChar = keyOrDefault(options, SETTING_NAME_HYPH_CHAR, SETTING_DEFAULT_HYPH_CHAR),\n      patterns = patternsDefinition.patterns.map(preprocessPattern),\n      minWordLength = keyOrDefault(options, SETTING_NAME_MIN_WORD_LENGTH, SETTING_DEFAULT_MIN_WORD_LENGTH) >> 0,\n      skipHTML = keyOrDefault(options, SETTING_NAME_HTML, SETTING_DEFAULT_HTML);\n\n    // Prepare cache\n    var cacheKey = hyphenChar + minWordLength;\n    exceptions[cacheKey] = exceptionsFromDefinition(patternsDefinition, hyphenChar);\n    caches[cacheKey] = cloneObj(exceptions[cacheKey]);\n    if (asyncMode && !(\"Promise\" in _global)) {\n      throw new Error(\"Failed to create hyphenator: Could not find global Promise object, needed for hyphenator to work in async mode\");\n    }\n    return function (text, options) {\n      options = options || {};\n      var localDebug = keyOrDefault(options, SETTING_NAME_DEBUG, debug),\n        localHyphenChar = keyOrDefault(options, SETTING_NAME_HYPH_CHAR, hyphenChar),\n        localMinWordLength = keyOrDefault(options, SETTING_NAME_MIN_WORD_LENGTH, minWordLength) >> 0,\n        cacheKey = localHyphenChar + localMinWordLength;\n      if (!exceptions[cacheKey]) {\n        exceptions[cacheKey] = exceptionsFromDefinition(patternsDefinition, localHyphenChar);\n      }\n      if (!caches[cacheKey]) {\n        caches[cacheKey] = cloneObj(exceptions[cacheKey]);\n      }\n      return start(text, patterns, caches[cacheKey], localDebug, localHyphenChar, skipHTML, localMinWordLength, asyncMode);\n    };\n  }\n  function createTextChunkReader(text, hyphenChar, skipHTML, minWordLength) {\n    function readNextTextChunk() {\n      var nextTextChunk = \"\";\n      shouldHyphenate = void 0;\n      chunkReader: while (nextCharIndex <= text.length) {\n        var\n          //\n          nextChar = text.charAt(nextCharIndex++),\n          charIsLetter = !!nextChar && !/\\s|[\\!-\\@\\[-\\`\\{-\\~\\u2013-\\u203C]/.test(nextChar),\n          charIsAngleOpen = nextChar === \"<\",\n          charIsAngleClose = nextChar === \">\",\n          charIsHyphen = nextChar === hyphenChar;\n        do {\n          if (state === STATE_READ_TAG) {\n            if (charIsAngleClose) {\n              state = STATE_RETURN_UNTOUCHED;\n            }\n            break;\n          }\n          if (charIsHyphen) {\n            shouldHyphenate = SHOULD_SKIP;\n            state = STATE_READ_WORD;\n            break;\n          }\n          if (charIsLetter) {\n            state = STATE_READ_WORD;\n            break;\n          }\n          if (state === STATE_READ_WORD) {\n            state = STATE_RETURN_WORD;\n            shouldHyphenate = shouldHyphenate || nextTextChunk.length >= minWordLength && SHOULD_HYPHENATE;\n            break;\n          }\n          shouldHyphenate = SHOULD_SKIP;\n          state = STATE_RETURN_UNTOUCHED;\n        } while (0);\n        if (charIsAngleOpen && state !== STATE_RETURN_WORD && skipHTML && !isSpacelike(text.charAt(nextCharIndex))) {\n          shouldHyphenate = SHOULD_SKIP;\n          state = STATE_READ_TAG;\n        }\n        switch (state) {\n          case STATE_READ_TAG:\n            nextTextChunk += nextChar;\n            break;\n          case STATE_READ_WORD:\n            nextTextChunk += nextChar;\n            break;\n          case STATE_RETURN_UNTOUCHED:\n            nextTextChunk += nextChar;\n            break chunkReader;\n          case STATE_RETURN_WORD:\n            nextCharIndex--;\n            break chunkReader;\n        }\n      }\n      return nextTextChunk || void 0;\n    }\n    function shouldNextHyphenate() {\n      return shouldHyphenate === SHOULD_HYPHENATE;\n    }\n    var isSpacelike = RegExp.prototype.test.bind(/\\s/);\n    var\n      //\n      nextCharIndex = 0,\n      SHOULD_HYPHENATE = 1,\n      SHOULD_SKIP = 2,\n      shouldHyphenate,\n      STATE_READ_TAG = 1,\n      STATE_READ_WORD = 2,\n      STATE_RETURN_UNTOUCHED = 3,\n      STATE_RETURN_WORD = 4,\n      state;\n    return [readNextTextChunk, shouldNextHyphenate];\n  }\n  function hyphenateWord(text, patterns, debug, hyphenChar) {\n    var\n      //\n      levels = new Array(text.length + 1),\n      loweredText = text.toLocaleLowerCase(),\n      p = [],\n      patternData,\n      patternIndex = 0;\n    for (var i = levels.length; i--;) levels[i] = 0;\n    while (patternData = patterns[patternIndex++]) {\n      var\n        //\n        fromChar = 0,\n        endPattern = false;\n      while (!endPattern) {\n        var\n          //\n          patternEntityIndex = loweredText.indexOf(patternData.text, fromChar),\n          patternFits = patternEntityIndex > -1 && (patternData.stickToLeft ? patternEntityIndex === 0 : true) && (patternData.stickToRight ? patternEntityIndex + patternData.text.length === text.length : true);\n        if (patternFits) {\n          p.push(patternData.pattern + \">\" + patternData.levels.join(\"\"));\n          for (var i = 0; i < patternData.levels.length; i++) levels[patternEntityIndex + i] = Math.max(patternData.levels[i], levels[patternEntityIndex + i]);\n        }\n        if (patternEntityIndex > -1 && patternData.text.length > 0) {\n          fromChar = patternEntityIndex + patternData.text.length + 1;\n        } else {\n          endPattern = true;\n        }\n      }\n    }\n    levels[0] = levels[1] = levels[levels.length - 1] = levels[levels.length - 2] = 0;\n    var\n      //\n      hyphenatedText = \"\",\n      leveledText = \"\",\n      debugHyphenatedText = \"\";\n    for (var i = 0; i < levels.length; i++) {\n      hyphenatedText += (levels[i] % 2 === 1 ? hyphenChar : \"\") + text.charAt(i);\n      debugHyphenatedText += (levels[i] % 2 === 1 ? \"-\" : \"\") + text.charAt(i);\n      leveledText += (levels[i] > 0 ? levels[i] : \"\") + text.charAt(i);\n    }\n    if (debug) console.log.apply(console, [text, \"->\"].concat(p).concat([\"->\"]).concat(levels).concat([\"->\", leveledText]).concat([\"->\", debugHyphenatedText]));\n    return hyphenatedText;\n  }\n  function preprocessPattern(pattern) {\n    var\n      //\n      patternCharIndex = 0,\n      patternChar,\n      patternData = {\n        pattern: pattern,\n        text: \"\",\n        levels: [],\n        stickToLeft: 0,\n        stickToRight: 0\n      },\n      states = {\n        alphabet: 1,\n        level: 2,\n        stickToLeft: 3,\n        stickToRight: 4\n      };\n    while (patternChar = pattern.charAt(patternCharIndex++)) {\n      var\n        //\n        charIsDot = patternChar === \".\",\n        charIsNumber = !charIsDot && /\\d/.test(patternChar),\n        state = charIsDot ? patternCharIndex - 1 === 0 ? states.stickToLeft : states.stickToRight : charIsNumber ? states.level : states.alphabet;\n      switch (state) {\n        case states.alphabet:\n          !prevCharIsNumber && patternData.levels.push(0);\n          patternData.text += patternChar;\n          break;\n        case states.level:\n          patternData.levels.push(parseInt(patternChar));\n          break;\n        case states.stickToLeft:\n          patternData.stickToLeft = true;\n          break;\n        case states.stickToRight:\n          patternData.stickToRight = true;\n          break;\n      }\n      var prevCharIsNumber = charIsNumber;\n    }\n    return patternData;\n  }\n  function start(text, patterns, cache, debug, hyphenChar, skipHTML, minWordLength, isAsync) {\n    function done() {\n      allTime = new Date() - allTime;\n      resolveNewText(newText);\n      if (debug) {\n        console.log(\"----------------\\nHyphenation stats: \" + processedN + \" text chunks processed, \" + hyphenatedN + \" words hyphenated\");\n        console.log(\"Work time: \" + workTime / 1000);\n        console.log(\"Wait time: \" + (allTime - workTime) / 1000);\n        console.log(\"All time: \" + allTime / 1000);\n      }\n    }\n    var\n      //\n      cacheKey,\n      newText = \"\",\n      textChunk,\n      reader = createTextChunkReader(text, hyphenChar, skipHTML, minWordLength),\n      readNextTextChunk = reader[0],\n      shouldNextHyphenate = reader[1],\n      processedN = 0,\n      hyphenatedN = 0;\n    var\n      //\n      allTime = new Date(),\n      workTime = 0;\n    var resolveNewText = function () {};\n    function nextTick() {\n      var loopStart = new Date();\n      while ((!isAsync || new Date() - loopStart < 10) && (textChunk = readNextTextChunk())) {\n        cacheKey = textChunk.length ? \"$\" + textChunk : \"\";\n        if (shouldNextHyphenate()) {\n          if (cache[cacheKey] === undefined) {\n            cache[cacheKey] = hyphenateWord(textChunk, patterns, debug, hyphenChar);\n          }\n          if (textChunk !== cache[cacheKey]) {\n            hyphenatedN++;\n          }\n          textChunk = cache[cacheKey];\n        }\n        newText += textChunk;\n        processedN++;\n      }\n      workTime += new Date() - loopStart;\n      if (!textChunk) {\n        done();\n      } else {\n        setTimeout(nextTick);\n      }\n    }\n    if (isAsync) {\n      setTimeout(nextTick);\n      return new Promise(function (resolve) {\n        resolveNewText = resolve;\n      });\n    } else {\n      nextTick();\n      return newText;\n    }\n  }\n  return createHyphenator;\n});","map":{"version":3,"names":["root","factory","define","amd","module","exports","createHyphenator","SETTING_DEFAULT_ASYNC","SETTING_DEFAULT_DEBUG","SETTING_DEFAULT_HTML","SETTING_DEFAULT_HYPH_CHAR","SETTING_DEFAULT_MIN_WORD_LENGTH","SETTING_NAME_ASYNC","SETTING_NAME_DEBUG","SETTING_NAME_HTML","SETTING_NAME_HYPH_CHAR","SETTING_NAME_MIN_WORD_LENGTH","_global","global","window","cloneObj","source","target","key","keyOrDefault","object","defaultValue","exceptionsFromDefinition","patternsDefinition","hyphenChar","exceptions","reduce","exception","replace","options","asyncMode","caches","debug","patterns","map","preprocessPattern","minWordLength","skipHTML","cacheKey","Error","text","localDebug","localHyphenChar","localMinWordLength","start","createTextChunkReader","readNextTextChunk","nextTextChunk","shouldHyphenate","chunkReader","nextCharIndex","length","nextChar","charAt","charIsLetter","test","charIsAngleOpen","charIsAngleClose","charIsHyphen","state","STATE_READ_TAG","STATE_RETURN_UNTOUCHED","SHOULD_SKIP","STATE_READ_WORD","STATE_RETURN_WORD","SHOULD_HYPHENATE","isSpacelike","shouldNextHyphenate","RegExp","prototype","bind","hyphenateWord","levels","Array","loweredText","toLocaleLowerCase","p","patternData","patternIndex","i","fromChar","endPattern","patternEntityIndex","indexOf","patternFits","stickToLeft","stickToRight","push","pattern","join","Math","max","hyphenatedText","leveledText","debugHyphenatedText","console","log","apply","concat","patternCharIndex","patternChar","states","alphabet","level","charIsDot","charIsNumber","prevCharIsNumber","parseInt","cache","isAsync","done","allTime","Date","resolveNewText","newText","processedN","hyphenatedN","workTime","textChunk","reader","nextTick","loopStart","undefined","setTimeout","Promise","resolve"],"sources":["C:/Users/Abdullah/Desktop/Project/TTP-Project/client/node_modules/hyphen/hyphen.js"],"sourcesContent":["/** Text hyphenation in Javascript.\n *  Copyright (C) 2021 Yevhen Tiurin (yevhentiurin@gmail.com)\n *  https://github.com/ytiurin/hyphen\n *\n *  Released under the ISC license\n *  https://github.com/ytiurin/hyphen/blob/master/LICENSE\n */\n(function (root, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof module === \"object\" && module.exports) {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    // Browser globals (root is window)\n    root.createHyphenator = factory();\n  }\n})(this, function () {\n  var SETTING_DEFAULT_ASYNC = false,\n    SETTING_DEFAULT_DEBUG = false,\n    SETTING_DEFAULT_HTML = false,\n    SETTING_DEFAULT_HYPH_CHAR = \"\\u00AD\",\n    SETTING_DEFAULT_MIN_WORD_LENGTH = 5,\n    SETTING_NAME_ASYNC = \"async\",\n    SETTING_NAME_DEBUG = \"debug\",\n    SETTING_NAME_HTML = \"html\",\n    SETTING_NAME_HYPH_CHAR = \"hyphenChar\",\n    SETTING_NAME_MIN_WORD_LENGTH = \"minWordLength\";\n\n  var _global =\n    typeof global === \"object\"\n      ? global\n      : typeof window === \"object\"\n      ? window\n      : typeof this === \"object\"\n      ? this\n      : {};\n\n  function cloneObj(source) {\n    var target = {};\n    for (var key in source) {\n      target[key] = source[key];\n    }\n    return target;\n  }\n\n  function keyOrDefault(object, key, defaultValue) {\n    if (key in object) {\n      return object[key];\n    }\n    return defaultValue;\n  }\n\n  function exceptionsFromDefinition(patternsDefinition, hyphenChar) {\n    return patternsDefinition.exceptions.reduce(function (\n      exceptions,\n      exception\n    ) {\n      exceptions[exception.replace(/\\-/g, \"\")] = exception.replace(\n        /\\-/g,\n        hyphenChar\n      );\n      return exceptions;\n    },\n    {});\n  }\n\n  function createHyphenator(patternsDefinition, options) {\n    options = options || {};\n    var //\n      asyncMode = keyOrDefault(\n        options,\n        SETTING_NAME_ASYNC,\n        SETTING_DEFAULT_ASYNC\n      ),\n      caches = {},\n      debug = keyOrDefault(options, SETTING_NAME_DEBUG, SETTING_DEFAULT_DEBUG),\n      exceptions = {},\n      hyphenChar = keyOrDefault(\n        options,\n        SETTING_NAME_HYPH_CHAR,\n        SETTING_DEFAULT_HYPH_CHAR\n      ),\n      patterns = patternsDefinition.patterns.map(preprocessPattern),\n      minWordLength =\n        keyOrDefault(\n          options,\n          SETTING_NAME_MIN_WORD_LENGTH,\n          SETTING_DEFAULT_MIN_WORD_LENGTH\n        ) >> 0,\n      skipHTML = keyOrDefault(options, SETTING_NAME_HTML, SETTING_DEFAULT_HTML);\n\n    // Prepare cache\n    var cacheKey = hyphenChar + minWordLength;\n    exceptions[cacheKey] = exceptionsFromDefinition(\n      patternsDefinition,\n      hyphenChar\n    );\n    caches[cacheKey] = cloneObj(exceptions[cacheKey]);\n\n    if (asyncMode && !(\"Promise\" in _global)) {\n      throw new Error(\n        \"Failed to create hyphenator: Could not find global Promise object, needed for hyphenator to work in async mode\"\n      );\n    }\n\n    return function (text, options) {\n      options = options || {};\n\n      var localDebug = keyOrDefault(options, SETTING_NAME_DEBUG, debug),\n        localHyphenChar = keyOrDefault(\n          options,\n          SETTING_NAME_HYPH_CHAR,\n          hyphenChar\n        ),\n        localMinWordLength =\n          keyOrDefault(options, SETTING_NAME_MIN_WORD_LENGTH, minWordLength) >>\n          0,\n        cacheKey = localHyphenChar + localMinWordLength;\n\n      if (!exceptions[cacheKey]) {\n        exceptions[cacheKey] = exceptionsFromDefinition(\n          patternsDefinition,\n          localHyphenChar\n        );\n      }\n\n      if (!caches[cacheKey]) {\n        caches[cacheKey] = cloneObj(exceptions[cacheKey]);\n      }\n\n      return start(\n        text,\n        patterns,\n        caches[cacheKey],\n        localDebug,\n        localHyphenChar,\n        skipHTML,\n        localMinWordLength,\n        asyncMode\n      );\n    };\n  }\n  function createTextChunkReader(text, hyphenChar, skipHTML, minWordLength) {\n    function readNextTextChunk() {\n      var nextTextChunk = \"\";\n\n      shouldHyphenate = void 0;\n\n      chunkReader: while (nextCharIndex <= text.length) {\n        var //\n          nextChar = text.charAt(nextCharIndex++),\n          charIsLetter =\n            !!nextChar && !/\\s|[\\!-\\@\\[-\\`\\{-\\~\\u2013-\\u203C]/.test(nextChar),\n          charIsAngleOpen = nextChar === \"<\",\n          charIsAngleClose = nextChar === \">\",\n          charIsHyphen = nextChar === hyphenChar;\n\n        do {\n          if (state === STATE_READ_TAG) {\n            if (charIsAngleClose) {\n              state = STATE_RETURN_UNTOUCHED;\n            }\n            break;\n          }\n\n          if (charIsHyphen) {\n            shouldHyphenate = SHOULD_SKIP;\n            state = STATE_READ_WORD;\n            break;\n          }\n\n          if (charIsLetter) {\n            state = STATE_READ_WORD;\n            break;\n          }\n\n          if (state === STATE_READ_WORD) {\n            state = STATE_RETURN_WORD;\n            shouldHyphenate =\n              shouldHyphenate ||\n              (nextTextChunk.length >= minWordLength && SHOULD_HYPHENATE);\n            break;\n          }\n\n          shouldHyphenate = SHOULD_SKIP;\n          state = STATE_RETURN_UNTOUCHED;\n        } while (0);\n\n        if (\n          charIsAngleOpen &&\n          state !== STATE_RETURN_WORD &&\n          skipHTML &&\n          !isSpacelike(text.charAt(nextCharIndex))\n        ) {\n          shouldHyphenate = SHOULD_SKIP;\n          state = STATE_READ_TAG;\n        }\n\n        switch (state) {\n          case STATE_READ_TAG:\n            nextTextChunk += nextChar;\n            break;\n\n          case STATE_READ_WORD:\n            nextTextChunk += nextChar;\n            break;\n\n          case STATE_RETURN_UNTOUCHED:\n            nextTextChunk += nextChar;\n            break chunkReader;\n\n          case STATE_RETURN_WORD:\n            nextCharIndex--;\n            break chunkReader;\n        }\n      }\n      return nextTextChunk || void 0;\n    }\n\n    function shouldNextHyphenate() {\n      return shouldHyphenate === SHOULD_HYPHENATE;\n    }\n\n    var isSpacelike = RegExp.prototype.test.bind(/\\s/);\n\n    var //\n      nextCharIndex = 0,\n      SHOULD_HYPHENATE = 1,\n      SHOULD_SKIP = 2,\n      shouldHyphenate,\n      STATE_READ_TAG = 1,\n      STATE_READ_WORD = 2,\n      STATE_RETURN_UNTOUCHED = 3,\n      STATE_RETURN_WORD = 4,\n      state;\n\n    return [readNextTextChunk, shouldNextHyphenate];\n  }\n  function hyphenateWord(text, patterns, debug, hyphenChar) {\n    var //\n      levels = new Array(text.length + 1),\n      loweredText = text.toLocaleLowerCase(),\n      p = [],\n      patternData,\n      patternIndex = 0;\n\n    for (var i = levels.length; i--; ) levels[i] = 0;\n\n    while ((patternData = patterns[patternIndex++])) {\n      var //\n        fromChar = 0,\n        endPattern = false;\n      while (!endPattern) {\n        var //\n          patternEntityIndex = loweredText.indexOf(patternData.text, fromChar),\n          patternFits =\n            patternEntityIndex > -1 &&\n            (patternData.stickToLeft ? patternEntityIndex === 0 : true) &&\n            (patternData.stickToRight\n              ? patternEntityIndex + patternData.text.length === text.length\n              : true);\n\n        if (patternFits) {\n          p.push(patternData.pattern + \">\" + patternData.levels.join(\"\"));\n\n          for (var i = 0; i < patternData.levels.length; i++)\n            levels[patternEntityIndex + i] = Math.max(\n              patternData.levels[i],\n              levels[patternEntityIndex + i]\n            );\n        }\n        if (patternEntityIndex > -1 && patternData.text.length > 0) {\n          fromChar = patternEntityIndex + patternData.text.length + 1;\n        } else {\n          endPattern = true;\n        }\n      }\n    }\n\n    levels[0] = levels[1] = levels[levels.length - 1] = levels[\n      levels.length - 2\n    ] = 0;\n\n    var //\n      hyphenatedText = \"\",\n      leveledText = \"\",\n      debugHyphenatedText = \"\";\n\n    for (var i = 0; i < levels.length; i++) {\n      hyphenatedText +=\n        (levels[i] % 2 === 1 ? hyphenChar : \"\") + text.charAt(i);\n      debugHyphenatedText += (levels[i] % 2 === 1 ? \"-\" : \"\") + text.charAt(i);\n      leveledText += (levels[i] > 0 ? levels[i] : \"\") + text.charAt(i);\n    }\n\n    if (debug)\n      console.log.apply(\n        console,\n        [text, \"->\"]\n          .concat(p)\n          .concat([\"->\"])\n          .concat(levels)\n          .concat([\"->\", leveledText])\n          .concat([\"->\", debugHyphenatedText])\n      );\n\n    return hyphenatedText;\n  }\n  function preprocessPattern(pattern) {\n    var //\n      patternCharIndex = 0,\n      patternChar,\n      patternData = {\n        pattern: pattern,\n        text: \"\",\n        levels: [],\n        stickToLeft: 0,\n        stickToRight: 0\n      },\n      states = { alphabet: 1, level: 2, stickToLeft: 3, stickToRight: 4 };\n\n    while ((patternChar = pattern.charAt(patternCharIndex++))) {\n      var //\n        charIsDot = patternChar === \".\",\n        charIsNumber = !charIsDot && /\\d/.test(patternChar),\n        state = charIsDot\n          ? patternCharIndex - 1 === 0\n            ? states.stickToLeft\n            : states.stickToRight\n          : charIsNumber\n          ? states.level\n          : states.alphabet;\n\n      switch (state) {\n        case states.alphabet:\n          !prevCharIsNumber && patternData.levels.push(0);\n          patternData.text += patternChar;\n          break;\n\n        case states.level:\n          patternData.levels.push(parseInt(patternChar));\n          break;\n\n        case states.stickToLeft:\n          patternData.stickToLeft = true;\n          break;\n\n        case states.stickToRight:\n          patternData.stickToRight = true;\n          break;\n      }\n\n      var prevCharIsNumber = charIsNumber;\n    }\n\n    return patternData;\n  }\n  function start(\n    text,\n    patterns,\n    cache,\n    debug,\n    hyphenChar,\n    skipHTML,\n    minWordLength,\n    isAsync\n  ) {\n    function done() {\n      allTime = new Date() - allTime;\n      resolveNewText(newText);\n\n      if (debug) {\n        console.log(\n          \"----------------\\nHyphenation stats: \" +\n            processedN +\n            \" text chunks processed, \" +\n            hyphenatedN +\n            \" words hyphenated\"\n        );\n        console.log(\"Work time: \" + workTime / 1000);\n        console.log(\"Wait time: \" + (allTime - workTime) / 1000);\n        console.log(\"All time: \" + allTime / 1000);\n      }\n    }\n\n    var //\n      cacheKey,\n      newText = \"\",\n      textChunk,\n      reader = createTextChunkReader(text, hyphenChar, skipHTML, minWordLength),\n      readNextTextChunk = reader[0],\n      shouldNextHyphenate = reader[1],\n      processedN = 0,\n      hyphenatedN = 0;\n\n    var //\n      allTime = new Date(),\n      workTime = 0;\n\n    var resolveNewText = function () {};\n\n    function nextTick() {\n      var loopStart = new Date();\n\n      while (\n        (!isAsync || new Date() - loopStart < 10) &&\n        (textChunk = readNextTextChunk())\n      ) {\n        cacheKey = textChunk.length ? \"$\" + textChunk : \"\";\n\n        if (shouldNextHyphenate()) {\n          if (cache[cacheKey] === undefined) {\n            cache[cacheKey] = hyphenateWord(\n              textChunk,\n              patterns,\n              debug,\n              hyphenChar\n            );\n          }\n\n          if (textChunk !== cache[cacheKey]) {\n            hyphenatedN++;\n          }\n\n          textChunk = cache[cacheKey];\n        }\n\n        newText += textChunk;\n        processedN++;\n      }\n\n      workTime += new Date() - loopStart;\n\n      if (!textChunk) {\n        done();\n      } else {\n        setTimeout(nextTick);\n      }\n    }\n\n    if (isAsync) {\n      setTimeout(nextTick);\n      return new Promise(function (resolve) {\n        resolveNewText = resolve;\n      });\n    } else {\n      nextTick();\n      return newText;\n    }\n  }\n\n  return createHyphenator;\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}