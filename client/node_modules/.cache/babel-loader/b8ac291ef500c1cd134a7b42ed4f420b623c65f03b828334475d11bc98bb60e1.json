{"ast":null,"code":"var Query = require('./queries');\nvar Operator = require('./operators');\nvar NUMBERS = /[0-9]/;\nvar LETTERS = /[a-z|\\-]/i;\nvar WHITESPACE = /\\s/;\nvar COLON = /:/;\nvar COMMA = /,/;\nvar AND = /and$/;\nvar AT = /@/;\nfunction tokenizer(input) {\n  var current = 0;\n  var tokens = [];\n  while (current < input.length) {\n    var char = input[current];\n    if (AT.test(char)) {\n      char = input[++current];\n      while (LETTERS.test(char) && char !== undefined) {\n        char = input[++current];\n      }\n    }\n    if (WHITESPACE.test(char) || char === ')' || char === '(') {\n      current++;\n      continue;\n    }\n    if (COLON.test(char) || COMMA.test(char)) {\n      current++;\n      tokens.push({\n        type: 'operator',\n        value: char\n      });\n      continue;\n    }\n    if (NUMBERS.test(char)) {\n      var value = '';\n      while (NUMBERS.test(char)) {\n        value += char;\n        char = input[++current];\n      }\n      tokens.push({\n        type: 'number',\n        value: value\n      });\n      continue;\n    }\n    if (LETTERS.test(char)) {\n      var value = '';\n      while (LETTERS.test(char) && char !== undefined) {\n        value += char;\n        char = input[++current];\n      }\n      if (AND.test(value)) {\n        tokens.push({\n          type: 'operator',\n          value: value\n        });\n      } else {\n        tokens.push({\n          type: 'literal',\n          value: value\n        });\n      }\n      continue;\n    }\n    throw new TypeError('Tokenizer: I dont know what this character is: ' + char);\n  }\n  return tokens;\n}\nfunction parser(tokens) {\n  var output = [];\n  var stack = [];\n  while (tokens.length > 0) {\n    var token = tokens.shift();\n    if (token.type === 'number' || token.type === 'literal') {\n      output.push(token);\n      continue;\n    }\n    if (token.type === 'operator') {\n      if (COLON.test(token.value)) {\n        token = {\n          type: 'query',\n          key: output.pop(),\n          value: tokens.shift()\n        };\n        output.push(token);\n        continue;\n      }\n      while (stack.length > 0) {\n        output.unshift(stack.pop());\n      }\n      stack.push(token);\n    }\n  }\n  while (stack.length > 0) {\n    output.unshift(stack.pop());\n  }\n  function walk() {\n    var head = output.shift();\n    if (head.type === 'number') {\n      return parseInt(head.value);\n    }\n    if (head.type === 'literal') {\n      return head.value;\n    }\n    if (head.type === 'operator') {\n      var l = walk();\n      var r = walk();\n      return Operator(head.value, l, r);\n    }\n    if (head.type === 'query') {\n      var l = head.key.value;\n      var r = head.value.value;\n      return Query(l, r);\n    }\n  }\n  return walk();\n}\nmodule.exports = {\n  parse: function (query) {\n    var tokens = tokenizer(query);\n    var ast = parser(tokens);\n    return ast;\n  }\n};","map":{"version":3,"names":["Query","require","Operator","NUMBERS","LETTERS","WHITESPACE","COLON","COMMA","AND","AT","tokenizer","input","current","tokens","length","char","test","undefined","push","type","value","TypeError","parser","output","stack","token","shift","key","pop","unshift","walk","head","parseInt","l","r","module","exports","parse","query","ast"],"sources":["C:/Users/Abdullah/Desktop/Project/TTP-Project/client/node_modules/media-engine/src/parser.js"],"sourcesContent":["var Query = require('./queries');\nvar Operator = require('./operators');\n\nvar NUMBERS = /[0-9]/;\nvar LETTERS = /[a-z|\\-]/i;\nvar WHITESPACE = /\\s/;\nvar COLON = /:/;\nvar COMMA = /,/;\nvar AND = /and$/;\nvar AT = /@/;\n\nfunction tokenizer(input) {\n  var current = 0;\n  var tokens = [];\n\n  while (current < input.length) {\n    var char = input[current];\n\n    if (AT.test(char)) {\n      char = input[++current];\n      while (LETTERS.test(char) && char !== undefined) {\n        char = input[++current];\n      }\n    }\n\n    if (WHITESPACE.test(char) || char === ')' || char === '(') {\n      current++;\n      continue;\n    }\n\n    if (COLON.test(char) || COMMA.test(char)) {\n      current++;\n      tokens.push({ type: 'operator', value: char });\n      continue;\n    }\n\n    if (NUMBERS.test(char)) {\n      var value = '';\n      while (NUMBERS.test(char)) {\n        value += char;\n        char = input[++current];\n      }\n\n      tokens.push({ type: 'number', value: value });\n      continue;\n    }\n\n    if (LETTERS.test(char)) {\n      var value = '';\n      while (LETTERS.test(char) && char !== undefined) {\n        value += char;\n        char = input[++current];\n      }\n      if (AND.test(value)) {\n        tokens.push({ type: 'operator', value: value });\n      } else {\n        tokens.push({ type: 'literal', value: value });\n      }\n\n      continue;\n    }\n\n    throw new TypeError(\n      'Tokenizer: I dont know what this character is: ' + char\n    );\n  }\n\n  return tokens;\n}\n\nfunction parser(tokens) {\n  var output = [];\n  var stack = [];\n\n  while (tokens.length > 0) {\n    var token = tokens.shift();\n\n    if (token.type === 'number' || token.type === 'literal') {\n      output.push(token);\n      continue;\n    }\n\n    if (token.type === 'operator') {\n      if (COLON.test(token.value)) {\n        token = { type: 'query', key: output.pop(), value: tokens.shift() };\n        output.push(token);\n        continue;\n      }\n\n      while (stack.length > 0) {\n        output.unshift(stack.pop());\n      }\n      stack.push(token);\n    }\n  }\n\n  while (stack.length > 0) {\n    output.unshift(stack.pop());\n  }\n\n  function walk() {\n    var head = output.shift();\n\n    if (head.type === 'number') {\n      return parseInt(head.value);\n    }\n\n    if (head.type === 'literal') {\n      return head.value;\n    }\n\n    if (head.type === 'operator') {\n      var l = walk();\n      var r = walk();\n\n      return Operator(head.value, l, r);\n    }\n\n    if (head.type === 'query') {\n      var l = head.key.value;\n      var r = head.value.value;\n\n      return Query(l, r);\n    }\n  }\n\n  return walk();\n}\n\nmodule.exports = {\n  parse: function(query) {\n    var tokens = tokenizer(query);\n    var ast = parser(tokens);\n    return ast;\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}